#N canvas 32 64 543 721 10;
#X obj 320 94 inlet;
#X obj 164 317 *;
#X obj 164 341 del;
#X obj 62 348 r reset-stop;
#X obj 274 461 outlet;
#X obj 276 384 pointer;
#X obj 164 367 t b b;
#X obj 164 403 s next-evt;
#X obj 180 295 r delay-multiplier;
#X text 35 24 Here we carry out the actual sequencing. Argument is
template of the scalar. Note the sends and receives which must agree
with the rest of the patch.;
#X obj 164 161 get \$1 x;
#X text 40 69 inlet: pointer;
#X text 40 90 outlet: same pointer \, delayed;
#X text 35 324 later use vdel:;
#X obj 222 202 r data-beatparams;
#X obj 222 249 s data-beatparams;
#X obj 193 181 r data-beatnow;
#X obj 193 269 s data-beatnow;
#X obj 164 225 x-to-time;
#N canvas 419 257 562 406 fix-timestamp 0;
#X obj 84 37 inlet;
#X obj 46 320 outlet;
#X obj 46 105 spigot;
#X obj 232 112 spigot;
#X obj 401 64 r sequence-function;
#X obj 95 105 == 0;
#X obj 280 113 == 1;
#X obj 432 115 spigot;
#X obj 480 116 == 2;
#X obj 229 289 outlet;
#X obj 476 249 outlet;
#X connect 0 0 2 0;
#X connect 0 0 3 0;
#X connect 0 0 7 0;
#X connect 2 0 1 0;
#X connect 3 0 9 0;
#X connect 4 0 5 0;
#X connect 4 0 6 0;
#X connect 4 0 8 0;
#X connect 5 0 2 1;
#X connect 6 0 3 1;
#X connect 7 0 10 0;
#X connect 8 0 7 1;
#X restore 279 415 pd fix-timestamp;
#X obj 334 464 outlet;
#X obj 392 466 outlet;
#X connect 0 0 5 1;
#X connect 0 0 10 0;
#X connect 1 0 2 0;
#X connect 2 0 6 0;
#X connect 3 0 2 0;
#X connect 5 0 19 0;
#X connect 6 0 7 0;
#X connect 6 1 5 0;
#X connect 8 0 1 1;
#X connect 10 0 18 0;
#X connect 14 0 18 2;
#X connect 16 0 18 1;
#X connect 18 0 1 0;
#X connect 18 1 17 0;
#X connect 18 2 15 0;
#X connect 19 0 4 0;
#X connect 19 1 20 0;
#X connect 19 2 21 0;
